wait(0.2)
Player = game.Players.LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = Player.Character
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character.HumanoidRootPart
Torso = Character.Torso
Head = Character.Head
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart.RootJoint
Neck = Torso.Neck
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
local sick = Instance.new("Sound", Character)
sick.SoundId = "rbxassetid://1390506855"
sick.Looped = true
sick.Pitch = 1
sick.Volume = 1.5
sick:Play()
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id=" .. MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id=" .. TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end
function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end
Player_Size = 1
Animation_Speed = 3
Frame_Speed = 0.016666666666666666
local Speed = 16
local Effects2 = {}
local weldBetween = function(a, b)
	local weldd = Instance.new("ManualWeld")
	weldd.Part0 = a
	weldd.Part1 = b
	weldd.C0 = CFrame.new()
	weldd.C1 = b.CFrame:inverse() * a.CFrame
	weldd.Parent = a
	return weldd
end
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local CHANGEDEFENSE = 0
local CHANGEDAMAGE = 0
local CHANGEMOVEMENT = 0
local ANIM = "Idle"
local ATTACK = false
local EQUIPPED = false
local HOLD = false
local COMBO = 1
local Rooted = false
local SINE = 0
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local WALK = 0
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
local WEAPONGUI = IT("ScreenGui", PlayerGui)
WEAPONGUI.Name = "Weapon GUI"
local Effects = IT("Folder", Character)
Effects.Name = "Effects"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character.Animate
local HITPLAYERSOUNDS = {
	"263032172",
	"263032182",
	"263032200",
	"263032221",
	"263032252",
	"263033191"
}
local HITARMORSOUNDS = {
	"199149321",
	"199149338",
	"199149367",
	"199149409",
	"199149452"
}
local HITWEAPONSOUNDS = {
	"199148971",
	"199149025",
	"199149072",
	"199149109",
	"199149119"
}
local HITBLOCKSOUNDS = {"199148933", "199148947"}
local UNANCHOR = true
local LEVEL = 1
local Volume = 1.5
local SONG1 = "rbxassetid://1390506855"
local SONG2 = "rbxassetid://1418800825"
local CREATION = false
local TRANSFORMING = false
local CREATIONPOSE = "Idle"
local SKILLTEXTCOLOR = BRICKC("Gold").Color
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"
script:WaitForChild("ArtificialHB")
frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end
function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end
function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end
function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = ACOS(-cosTheta)
		local invSinTheta = 1 / SIN(theta)
		startInterp = SIN((t - 1) * theta) * invSinTheta
		finishInterp = SIN(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function Clerp(a, b, t)
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
	local frame = IT("Frame")
	frame.BackgroundTransparency = TRANSPARENCY
	frame.BorderSizePixel = BORDERSIZEPIXEL
	frame.Position = POSITION
	frame.Size = SIZE
	frame.BackgroundColor3 = COLOR
	frame.BorderColor3 = BORDERCOLOR
	frame.Name = NAME
	frame.Parent = PARENT
	return frame
end
function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
	local label = IT("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UD2(1, 0, 1, 0)
	label.Position = UD2(0, 0, 0, 0)
	label.TextColor3 = TEXTCOLOR
	label.TextStrokeTransparency = STROKETRANSPARENCY
	label.TextTransparency = TRANSPARENCY
	label.FontSize = TEXTFONTSIZE
	label.Font = TEXTFONT
	label.BorderSizePixel = BORDERSIZEPIXEL
	label.TextScaled = false
	label.Text = TEXT
	label.Name = NAME
	label.Parent = PARENT
	return label
end
function NoOutlines(PART)
	PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end
local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH)
	local NEWSOUND
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id=" .. ID
		Swait()
		NEWSOUND:play()
		game:GetService("Debris"):AddItem(NEWSOUND, 10)
	end))
	return NEWSOUND
end
function CFrameFromTopBack(at, top, back)
	local right = top:Cross(back)
	return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end
function CreateWave(SIZE, WAIT, CFRAME, DOESROT, ROT, COLOR, GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(0, 0, 0))
	local mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "20329976", "", SIZE, VT(0, 0, -SIZE.X / 8))
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			mesh.Offset = VT(0, 0, -(mesh.Scale.X / 8))
			if DOESROT == true then
				wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0, ROT, 0)
			end
			wave.Transparency = wave.Transparency + 0.5 / WAIT
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end
function CreateRing(SIZE, DOESROT, ROT, WAIT, CFRAME, COLOR, GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(0, 0, 0))
	local mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "559831844", "", SIZE, VT(0, 0, 0))
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			if DOESROT == true then
				wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0, ROT, 0)
			end
			wave.Transparency = wave.Transparency + 0.5 / WAIT
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end
function MagicSphere(SIZE, WAIT, CFRAME, COLOR, GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1, 1, 1), true)
	wave.Color = COLOR
	local mesh = CreateMesh("SpecialMesh", wave, "Sphere", "", "", SIZE, VT(0, 0, 0))
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.Transparency = wave.Transparency + 1 / WAIT
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end
function Slice(KIND, SIZE, WAIT, CFRAME, COLOR, GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(1, 1, 1), true)
	local mesh
	if KIND == "Base" then
		mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "448386996", "", VT(0, SIZE / 10, SIZE / 10), VT(0, 0, 0))
	elseif KIND == "Thin" then
		mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "662586858", "", VT(SIZE / 10, 0, SIZE / 10), VT(0, 0, 0))
	elseif KIND == "Round" then
		mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "662585058", "", VT(SIZE / 10, 0, SIZE / 10), VT(0, 0, 0))
	end
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW / 10
			wave.Transparency = wave.Transparency + 0.5 / WAIT
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end
function MakeForm(PART, TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh", PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh", PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh", PART)
		MSH.MeshType = "Wedge"
	end
end
function CheckTableForString(Table, String)
	for i, v in pairs(Table) do
		if string.find(string.lower(String), string.lower(v)) then
			return true
		end
	end
	return false
end
function CheckIntangible(Hit)
	local ProjectileNames = {
		"Water",
		"Arrow",
		"Projectile",
		"Effect",
		"Rail",
		"Lightning",
		"Bullet"
	}
	if Hit and Hit.Parent and (not Hit.CanCollide or CheckTableForString(ProjectileNames, Hit.Name)) and not Hit.Parent:FindFirstChild("Humanoid") then
		return true
	end
	return false
end
Debris = game:GetService("Debris")
function CastZapRay(StartPos, Vec, Length, Ignore, DelayIfHit)
	local Ignore = type(Ignore) == "table" and Ignore or {Ignore}
	local RayHit, RayPos, RayNormal = game:GetService("Workspace"):FindPartOnRayWithIgnoreList(Ray.new(StartPos, Vec * Length), Ignore)
	if RayHit and CheckIntangible(RayHit) then
		if DelayIfHit then
			wait()
		end
		RayHit, RayPos, RayNormal = CastZapRay(RayPos + Vec * 0.01, Vec, Length - (StartPos - RayPos).magnitude, Ignore, DelayIfHit)
	end
	return RayHit, RayPos, RayNormal
end
BaseLightning = IT("Part")
BaseLightning.Anchored = true
BaseLightning.CanCollide = false
BaseLightning.Material = "Neon"
local LightningBolts = {}
function Zap(Table)
	local StartPos, TargetPos, Character, Color = Table.StartPosition, Table.TargetPosition, Table.Character, Table.Color
	local Duration = Table.Duration or 2
	local Offset = Table.Offset or 2
	local Individualize = Table.Individualize or false
	local MaxRange = Table.MaxRange or 200
	local SegmentLength = Table.SegmentLength or 5
	local Transparency = Table.Transparency or 0
	local Ignore = Table.Ignore or {}
	local SIZE = Table.SIZE or 0.3
	if not (StartPos and TargetPos) or not Character then
		return
	end
	local LightningModel = IT("Folder", Effects)
	LightningModel.Name = "ZAPP"
	for i, v in pairs({Character, LightningModel}) do
		table.insert(Ignore, v)
	end
	local LastPos = StartPos
	local Direction = CFrame.new(StartPos, TargetPos).lookVector
	local RayHit, RayPos, RayNormal = CastZapRay(StartPos, Direction, MaxRange, Ignore, false)
	local RayLength = (StartPos - RayPos).Magnitude
	local Struck = false
	local TotalSegments = math.ceil(RayLength / SegmentLength)
	Direction = CFrame.new(StartPos, RayPos).lookVector
	local LightningBolt = IT("Model", Effects)
	LightningBolt.Name = "Lightning"
	if not Individualize then
		table.insert(LightningBolts, LightningBolt)
	end
	LastBolt = LightningBolt
	Debris:AddItem(LightningBolt, Duration)
	LightningBolt.Parent = LightningModel
	for i = 1, TotalSegments do
		if not Struck then
			local Entropy = Vector3.new(math.random() * Offset * 2.5 - Offset, math.random() * Offset * 2.5 - Offset, math.random() * Offset * 2.5 - Offset)
			local NewPos = StartPos + Direction * (RayLength * (i / TotalSegments)) + Entropy
			local SegmentVec = NewPos - LastPos
			local RayHit, RayPos, RayNormal = CastZapRay(LastPos, SegmentVec.Unit, SegmentVec.Magnitude, {Character, LightningModel}, false)
			local RayVec = LastPos - RayPos
			local LightningPart = BaseLightning:Clone()
			LightningPart.BrickColor = BrickColor.new(Color)
			LightningPart.Transparency = Transparency
			LightningPart.Size = Vector3.new(SIZE, SIZE, RayVec.Magnitude)
			LightningPart.CFrame = CFrame.new(LastPos, RayPos) * CFrame.new(0, 0, -(RayVec.Magnitude / 2))
			table.insert(Effects2, {
				LightningPart,
				"Disappear",
				0.025,
				1,
				1,
				1,
				2
			})
			local CylinderMesh = IT("CylinderMesh", LightningPart)
			local OrigCF = LightningPart.CFrame
			LightningPart.Size = Vector3.new(LightningPart.Size.X, LightningPart.Size.Z, LightningPart.Size.Y)
			LightningPart.CFrame = OrigCF * CFrame.Angles(math.pi / 2, 0, 0)
			LightningPart.Parent = LightningBolt
			LastPos = NewPos
		end
	end
	return {
		RayHit = RayHit,
		RayPos = RayPos,
		RayNormal = RayNormal,
		LightningModel = LightningModel
	}
end
local EyeSizes = {
	NumberSequenceKeypoint.new(0, 1, 0),
	NumberSequenceKeypoint.new(1, 0, 0)
}
local PE = Instance.new("ParticleEmitter")
PE.LightEmission = 0.8
PE.Color = ColorSequence.new(BRICKC("Gold").Color)
PE.Size = NumberSequence.new(EyeSizes)
PE.Lifetime = NumberRange.new(0.35, 0.35, 0.35)
PE.Rotation = NumberRange.new(0, 360)
PE.Transparency = NumberSequence.new(0.9)
PE.Rate = 999
PE.VelocitySpread = 10000
PE.Acceleration = Vector3.new(0, 75, 0)
PE.Drag = 5
PE.Speed = NumberRange.new(6, 6)
PE.Texture = "http://www.roblox.com/asset/?id=1351966707"
PE.ZOffset = -1.5
PE.Name = "OVERLORDAURA"
function particles(art)
	PE:Clone().Parent = art
end
function turnto(position)
	RootPart.CFrame = CFrame.new(RootPart.CFrame.p, VT(position.X, RootPart.Position.Y, position.Z)) * CFrame.new(0, 0, 0)
end
function WACKYEFFECT(Table)
	local TYPE = Table.EffectType or "Sphere"
	local SIZE = Table.Size or VT(1, 1, 1)
	local ENDSIZE = Table.Size2 or VT(0, 0, 0)
	local TRANSPARENCY = Table.Transparency or 0
	local ENDTRANSPARENCY = Table.Transparency2 or 1
	local CFRAME = Table.CFrame or Torso.CFrame
	local MOVEDIRECTION = Table.MoveToPos or nil
	local ROTATION1 = Table.RotationX or 0
	local ROTATION2 = Table.RotationY or 0
	local ROTATION3 = Table.RotationZ or 0
	local MATERIAL = Table.Material or "Neon"
	local COLOR = Table.Color or C3(1, 1, 1)
	local TIME = Table.Time or 45
	local SOUNDID = Table.SoundID or nil
	local SOUNDPITCH = Table.SoundPitch or nil
	local SOUNDVOLUME = Table.SoundVolume or nil
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1, 1, 1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0, 0, 0))
		elseif TYPE == "Block" then
			MSH = IT("BlockMesh", EFFECT)
			MSH.Scale = VT(SIZE.X, SIZE.X, SIZE.X)
		elseif TYPE == "Box" then
			MSH = IT("BlockMesh", EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0, 0, -SIZE.X / 8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X, SIZE.X, 0.1), VT(0, 0, 0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X / 10, 0, SIZE.X / 10), VT(0, 0, 0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X / 10, 0, SIZE.X / 10), VT(0, 0, 0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0, 0, 0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0, 0, 0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0, 0, 0))
		end
		if MSH ~= nil then
			local MOVESPEED
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude / TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH / TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0, 0, -MSH.Scale.X / 8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS / TIME
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
				else
					EFFECT.CFrame = EFFECT.CFrame * ANGLES(RAD(ROTATION1), RAD(ROTATION2), RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position, MOVEDIRECTION) * CF(0, 0, -MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat
					Swait()
				until SOUND.Playing == false
				EFFECT:remove()
			end
		elseif PLAYSSOUND == false then
			EFFECT:remove()
		else
			repeat
				Swait()
			until SOUND.Playing == false
			EFFECT:remove()
		end
	end))
end
Head:ClearAllChildren()
local BODY = {}
local naeeym2 = Instance.new("BillboardGui", Character)
naeeym2.AlwaysOnTop = true
naeeym2.Size = UDim2.new(15, 35, 5, 15)
naeeym2.StudsOffset = Vector3.new(0, 3, 0)
naeeym2.Adornee = Character.Head
naeeym2.Name = "Name"
naeeym2.PlayerToHideFrom = Player
local tecks2 = Instance.new("TextLabel", naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.TextScaled = true
tecks2.BorderSizePixel = 0
tecks2.Text = "Dominus PHAEDRA"
tecks2.Font = "Fantasy"
tecks2.TextSize = 30
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = SKILLTEXTCOLOR
tecks2.TextStrokeColor3 = Color3.new(1, 1, 1)
tecks2.Size = UDim2.new(1, 0, 0.5, 0)
tecks2.Parent = naeeym2
function Transparency(TRANS)
	tecks2.TextTransparency = TRANS
	tecks2.TextStrokeTransparency = TRANS
	for _, c in pairs(Character:GetChildren()) do
		if c.ClassName == "Part" and c ~= RootPart then
			c.Transparency = TRANS
			if c:FindFirstChildOfClass("Decal") then
				c:FindFirstChildOfClass("Decal").Transparency = TRANS
			end
			if c:FindFirstChild("OVERLORDAURA") then
				c.OVERLORDAURA.Transparency = NumberSequence.new(0.9 + TRANS / 10)
			end
			if c:FindFirstChild("Eyeball") then
				c.Eyeball.Transparency = TRANS
			end
			if c:FindFirstChild("Eyeball1") then
				c.Eyeball1.Transparency = TRANS
			end
		elseif c.ClassName == "Accessory" then
			c.Handle.Transparency = TRANS
		elseif c.ClassName == "Model" then
			for _, q in pairs(c:GetChildren()) do
				if q.ClassName == "Part" then
					q.Transparency = TRANS
					if q:FindFirstChildOfClass("Decal") then
						q:FindFirstChildOfClass("Decal").Transparency = TRANS
					end
				end
			end
		end
	end
end
local EYE = CreatePart(3, Head, "Neon", 0, 0, "Gold", "Eyeball", VT(0.1, 0.4, 0.1), false)
MakeForm(EYE, "Ball")
EYE.CFrame = Head.CFrame * CF(0.2, 0.1, -0.72)
local EW = weldBetween(Head, EYE)
local EYE2 = CreatePart(3, Head, "Neon", 0, 0, "Gold", "Eyeball1", VT(0.4, 0.1, 0.1), false)
MakeForm(EYE2, "Ball")
EYE2.CFrame = Head.CFrame * CF(0.2, 0.1, -0.72)
local EW2 = weldBetween(Head, EYE2)
for _, c in pairs(Character:GetChildren()) do
	if c.ClassName == "Part" then
		table.insert(BODY, {c, Character})
		for _, q in pairs(c:GetChildren()) do
			if q ~= nil then
				table.insert(BODY, {q, c})
			end
		end
	end
end
function refit()
	Character.Parent = workspace
	for e = 1, #BODY do
		if BODY[e] ~= nil then
			local STUFF = BODY[e]
			local PART = STUFF[1]
			local PARENT = STUFF[2]
			PART.Parent = PARENT
		end
	end
end
Humanoid.HealthChanged:connect(function()
	local OLDHUM = Humanoid
	refit()
	OLDHUM:remove()
	Humanoid = IT("Humanoid", Character)
	Humanoid.MaxHealth = "inf"
	Humanoid.Health = "inf"
	Humanoid.PlatformStand = false
	Humanoid.HipHeight = 2.5
	Humanoid.WalkSpeed = Speed
end)
Humanoid.Died:connect(function()
	local OLDHUM = Humanoid
	refit()
	OLDHUM:remove()
	Humanoid = IT("Humanoid", Character)
	Humanoid.MaxHealth = "inf"
	Humanoid.Health = "inf"
	Humanoid.PlatformStand = false
	Humanoid.HipHeight = 2.5
	Humanoid.WalkSpeed = Speed
end)
local SKILL1FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.23, 0, 0.8, 0), UD2(0.26, 0, 0.07, 0), C3(0, 0, 0), C3(0, 0, 0), "Skill 1 Frame")
local SKILL2FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.5, 0, 0.8, 0), UD2(0.26, 0, 0.07, 0), C3(0, 0, 0), C3(0, 0, 0), "Skill 2 Frame")
local SKILL3FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.365, 0, 0.03, 0), UD2(0.26, 0, 0.07, 0), C3(0, 0, 0), C3(0, 0, 0), "Skill 3 Frame")
local SKILL1TEXT = CreateLabel(SKILL1FRAME, "[Z] Dolor Pluvia", SKILLTEXTCOLOR, 7, "Fantasy", 0, 2, 0, "Text 1")
local SKILL2TEXT = CreateLabel(SKILL2FRAME, "[B] Ignem Aeternum", SKILLTEXTCOLOR, 7, "Fantasy", 0, 2, 0, "Text 2")
local SKILL3TEXT = CreateLabel(SKILL3FRAME, "[X] Ultima Consummatio", SKILLTEXTCOLOR, 12, "Fantasy", 0, 2, 0, "Text 3")
local SKILLEFRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.365, 0, 0.13, 0), UD2(0.26, 0, 0.07, 0), C3(0, 0, 0), C3(0, 0, 0), "Skill Warp Frame")
local SKILLETEXT = CreateLabel(SKILLEFRAME, "[Q] Magia portam", SKILLTEXTCOLOR, 7, "Antique", 0, 2, 0, "Text Warp")
local SKILLFFRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.365, 0, 0.7, 0), UD2(0.26, 0, 0.07, 0), C3(0, 0, 0), C3(0, 0, 0), "Skill Warp Frame")
local SKILLFTEXT = CreateLabel(SKILLFFRAME, "[C] Imperium Delere", SKILLTEXTCOLOR, 7, "Antique", 0, 2, 0, "Text Warp")
function killnearest(position, range, maxstrength)
	for i, v in ipairs(workspace:GetChildren()) do
		do
			local body = v:GetChildren()
			for part = 1, #body do
				if (body[part].ClassName == "Part" or body[part].ClassName == "MeshPart") and v ~= Character and range > (body[part].Position - position).Magnitude then
					if v.ClassName == "Model" then
						v:BreakJoints()
					end
					local bv = Instance.new("BodyVelocity")
					bv.maxForce = Vector3.new(1000000000, 1000000000, 1000000000)
					bv.velocity = CF(position, body[part].Position).lookVector * maxstrength
					bv.Parent = body[part]
					Debris:AddItem(bv, 0.2)
					body[part].Parent = Effects
					body[part].Material = "Neon"
					body[part].BrickColor = BRICKC("Gold")
					coroutine.resume(coroutine.create(function()
						wait(5)
						if body[part].Parent == Effects then
							body[part]:remove()
						end
					end))
				end
			end
			if v.ClassName == "Part" and v.Anchored == false and range > (v.Position - position).Magnitude then
				v.Velocity = CFrame.new(position, v.Position).lookVector * 5 * maxstrength
			end
		end
	end
end
local Decal = IT("Decal")
function MagicRing()
	local O1 = CreatePart(3, Effects, "Neon", 0, 1, "Really red", "Warphole", VT(0, 0, 0))
	O1.CFrame = RootPart.CFrame * CF(0, 0, -3) * ANGLES(RAD(90), RAD(0), RAD(0))
	local decal = Decal:Clone()
	decal.Parent = O1
	decal.Face = "Top"
	decal.Texture = "http://www.roblox.com/asset/?id=917750924"
	local decal2 = Decal:Clone()
	decal2.Parent = O1
	decal2.Face = "Bottom"
	decal2.Texture = "http://www.roblox.com/asset/?id=917750924"
	return O1
end
function Dolor_Pluvia()
	local POWER = LEVEL
	local CENTER = MagicRing()
	CENTER.CFrame = CF(Mouse.Hit.p)
	CreateSound("424777055", CENTER, 10, 1)
	local RAIN = {}
	for i = 1, 45 do
		Swait()
		CENTER.Size = CENTER.Size + VT(POWER, 0, POWER)
		CENTER.CFrame = CENTER.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
	end
	for i = 1, 35 do
		Swait()
		coroutine.resume(coroutine.create(function()
			local DROP = CreatePart(3, Effects, "Neon", 0, 0, "Gold", "Raindrop", VT(POWER / 2, POWER / 2, POWER * 5))
			DROP.CFrame = CF(CENTER.Position + VT(MRANDOM(-CENTER.Size.X / 3, CENTER.Size.X / 3), 200, MRANDOM(-CENTER.Size.X / 3, CENTER.Size.X / 3)), CENTER.Position + VT(MRANDOM(-CENTER.Size.X / 2.5, CENTER.Size.X / 2.5), 0, MRANDOM(-CENTER.Size.X / 2.5, CENTER.Size.X / 2.5)))
			table.insert(RAIN, DROP)
			particles(DROP)
			MakeForm(DROP, "Ball")
			local IMPACT = false
			for i = 1, 80 do
				Swait()
				DROP.CFrame = DROP.CFrame * CF(0, 0, -7)
				local HIT = Raycast(DROP.Position, DROP.CFrame.lookVector, 6, Character)
				if HIT ~= nil then
					IMPACT = true
					break
				end
			end
			table.remove(RAIN, 1)
			if IMPACT == true then
				DROP.Transparency = 1
				DROP.OVERLORDAURA.Enabled = false
				MagicSphere(VT(0, 0, 0), 25, DROP.CFrame, BRICKC("Gold").Color, VT(POWER, POWER, POWER) / 2)
				killnearest(DROP.Position, POWER * 5, 500)
				Debris:AddItem(DROP, 5)
			else
				DROP:remove()
			end
		end))
	end
	repeat
		Swait()
	until #RAIN == 0
	for i = 1, 45 do
		Swait()
		CENTER.Size = CENTER.Size - VT(POWER, 0, POWER)
		CENTER.CFrame = CENTER.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
	end
	CENTER:remove()
end
function Ignem_Aeternum()
	local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
	if HITFLOOR ~= nil then
		do
			local POWER = LEVEL
			ATTACK = true
			Rooted = true
			local CENTER = MagicRing()
			CENTER.CFrame = CF(HITPOS + VT(0, 0.1, 0))
			CreateSound("424777055", CENTER, 10, 1)
			local RAIN = {}
			for i = 1, 55 do
				Swait()
				CENTER.Size = CENTER.Size + VT(POWER, 0, POWER) / 3
				CENTER.CFrame = CENTER.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(5 + 6.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-45 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			local MAXDIST = 15
			local DIRECTION = CF(RootPart.Position, VT(Mouse.Hit.p.X, HITPOS.Y, Mouse.Hit.p.Z)).lookVector
			local HITFLOOR2, HITPOS2 = Raycast(RootPart.Position, DIRECTION, MAXDIST, Character)
			local HITFLOOR3, HITPOS3 = Raycast(HITPOS2, CF(HITPOS2 + VT(0, 1, 0), HITPOS2 + VT(0, -1, 0)).lookVector, MAXDIST, Character)
			local ORB = CreatePart(3, Effects, "Neon", 0, 1, "Gold", "ORB", VT(4, 4, 4))
			MakeForm(ORB, "Ball")
			CreateSound("201858045", ORB, 10, 0.5)
			for i = 0, 1, 0.1 / Animation_Speed do
				Swait()
				ORB.CFrame = RootPart.CFrame * CF(0, 10 + POWER * 3, 0)
				ORB.Transparency = 0
				ORB.Size = ORB.Size + VT(POWER, POWER, POWER) / 7
				local POS = HITPOS + VT(MRANDOM(-CENTER.Size.X / 3, CENTER.Size.X / 3), 0, MRANDOM(-CENTER.Size.X / 3, CENTER.Size.X / 3))
				local RANGE = (POS - RootPart.CFrame * CF(0, 10 + POWER * 3, 0).p).Magnitude
				local ZAPTABLE = Zap({
					StartPosition = POS,
					TargetPosition = ORB.Position,
					Character = workspace,
					Color = "Gold",
					Individual = true,
					MaxRange = RANGE,
					SegmentLength = POWER * 2,
					Offset = 1
				})
				Debris:AddItem(ZAPTABLE.LightningModel, 0.1)
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 1.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(170), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			coroutine.resume(coroutine.create(function()
				ORB.CFrame = CF(ORB.Position, HITPOS3)
				local IMPACT = false
				for i = 1, 400 do
					Swait()
					ORB.CFrame = ORB.CFrame * CF(0, 0, -1)
					local HIT = Raycast(ORB.Position, ORB.CFrame.lookVector, ORB.Size.X / 2.2, Character)
					if HIT ~= nil then
						IMPACT = true
						break
					end
				end
				if IMPACT == true then
					ORB.Transparency = 1
					local FRONT = ORB.CFrame * CF(0, 0, -1).p
					ORB.CFrame = CF(ORB.Position, VT(FRONT.X, ORB.Position.Y, FRONT.Z))
					for i = 1, 35 do
						if MRANDOM(1, 5) == 1 then
							local POS = CF(ORB.Position) * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180))) * CF(0, 0, -POWER * 15).p
							local ZAPTABLE = Zap({
								SIZE = POWER,
								StartPosition = ORB.Position,
								TargetPosition = POS,
								Character = workspace,
								Color = "Gold",
								Individual = true,
								MaxRange = POWER * 35,
								SegmentLength = POWER * 5,
								Offset = 3
							})
							Debris:AddItem(ZAPTABLE.LightningModel, 0.1)
						end
						ORB.CFrame = ORB.CFrame * CF(0, 0, -ORB.Size.X / 1.5)
						MagicSphere(ORB.Size * 1.1, 25, ORB.CFrame, BRICKC("Gold").Color, -ORB.Size / 35)
						CreateWave(VT(ORB.Size.X, 1, ORB.Size.Z) * 5, 35, CF(ORB.Position - VT(0, ORB.Size.Y / 3, 0)) * ANGLES(RAD(0), RAD(i * 5), RAD(0)), true, 5, "Gold", -VT(ORB.Size.X / 24, 0, ORB.Size.Z / 24))
						killnearest(ORB.Position, ORB.Size.X * 2, 500)
						Swait()
					end
				else
					ORB:remove()
				end
			end))
			ATTACK = false
			Rooted = false
			coroutine.resume(coroutine.create(function()
				for i = 1, 55 do
					Swait()
					CENTER.Size = CENTER.Size - VT(POWER, 0, POWER)
					CENTER.CFrame = CENTER.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
				end
				CENTER:remove()
			end))
		end
	end
end
function Imperium_Delere()
	local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
	if HITFLOOR ~= nil then
		do
			local POWER = LEVEL
			ATTACK = true
			Rooted = true
			local CENTER = MagicRing()
			CENTER.CFrame = CF(HITPOS + VT(0, 0.1, 0))
			CreateSound("424777055", CENTER, 10, 1)
			local RAIN = {}
			for i = 1, 55 do
				Swait()
				CENTER.Size = CENTER.Size + VT(POWER, 0, POWER)
				CENTER.CFrame = CENTER.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(5 + 6.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-45 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			local VISUAL = CreatePart(3, Effects, "Neon", 0, 0.99, "Gold", "Vibrations", VT(45, 45, 45) * POWER)
			MakeForm(VISUAL, "Ball")
			VISUAL.CFrame = CF(HITPOS)
			for i = 1, 20 do
				Swait()
				VISUAL.Size = VISUAL.Size - VT(POWER, POWER, POWER) / 10
				VISUAL.Transparency = VISUAL.Transparency - 0.01
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(15 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-5 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			coroutine.resume(coroutine.create(function()
				for i = 1, 10 do
					Swait()
					CENTER.Size = CENTER.Size + VT(POWER, 0, POWER) * 15
					for _, c in pairs(workspace:GetChildren()) do
						if c.ClassName == "Model" then
							if c ~= Character and c:FindFirstChildOfClass("Humanoid") and (c:FindFirstChild("Torso") or c:FindFirstChild("UpperTorso")) then
								local HUMANOID = c:FindFirstChildOfClass("Humanoid")
								local TORSO = c:FindFirstChild("Torso") or c:FindFirstChild("UpperTorso")
								if (TORSO.Position - VISUAL.Position).Magnitude < VISUAL.Size.X / 1.6 then
									for _, q in pairs(c:GetChildren()) do
										if q.ClassName == "LocalScript" and q.Name ~= "Animate" then
											q:remove()
										end
									end
								end
							elseif c.ClassName == "LocalScript" then
								c:remove()
							end
						end
					end
					VISUAL.Size = VISUAL.Size + VT(POWER, POWER, POWER) * 12
					VISUAL.Transparency = VISUAL.Transparency + 0.01
				end
				VISUAL:remove()
				for i = 1, 40 do
					Swait()
					CENTER.Size = CENTER.Size * 0.9
				end
				CENTER:remove()
			end))
			ATTACK = false
			Rooted = false
		end
	end
end
function Ultima_Consummatio()
	local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 7, Character)
	if HITFLOOR ~= nil then
		do
			local POWER = LEVEL
			ATTACK = true
			Rooted = true
			if POWER <= 6 then
				do
					local CENTER = MagicRing()
					CENTER.CFrame = CF(HITPOS + VT(0, 0.1, 0))
					CreateSound("424777055", CENTER, 10, 1)
					local RAIN = {}
					for i = 1, 65 do
						Swait()
						CENTER.Size = CENTER.Size + VT(POWER, 0, POWER)
						CENTER.CFrame = CENTER.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
						RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 1.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(170), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					local ORB = CreatePart(3, Effects, "Neon", 0, 1, "Gold", "ORB", VT(4, 4, 4))
					MakeForm(ORB, "Ball")
					CreateSound("201858045", ORB, 10, 0.5)
					for i = 0, 5, 0.1 / Animation_Speed do
						Swait()
						ORB.CFrame = RootPart.CFrame * CF(0, 5 + ORB.Size.Y / 2, 0)
						ORB.Size = ORB.Size + VT(POWER, POWER, POWER) / 10
						ORB.Transparency = 0
						local POS = HITPOS + VT(MRANDOM(-CENTER.Size.X / 3, CENTER.Size.X / 3), 0, MRANDOM(-CENTER.Size.X / 3, CENTER.Size.X / 3))
						local RANGE = (POS - ORB.Position).Magnitude
						local ZAPTABLE = Zap({
							StartPosition = POS,
							TargetPosition = ORB.Position,
							Character = workspace,
							Color = "Gold",
							Individual = true,
							MaxRange = RANGE,
							SegmentLength = POWER * 2,
							Offset = 1
						})
						Debris:AddItem(ZAPTABLE.LightningModel, 0.1)
						RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 1.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(170), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					coroutine.resume(coroutine.create(function()
						if POWER <= 3 then
							local AIMPOS = Mouse.Hit.p
							local O1 = MagicRing()
							local O2 = MagicRing()
							local O3 = MagicRing()
							O1.CFrame = CF(ORB.Position, AIMPOS) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X, 0)
							O2.CFrame = CF(ORB.Position, AIMPOS) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X + ORB.Size.X / 4, 0)
							O3.CFrame = CF(ORB.Position, AIMPOS) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X + ORB.Size.X / 8, 0)
							for i = 1, 25 do
								Swait()
								O1.Size = O1.Size + VT(POWER, 0, POWER)
								O2.Size = O2.Size + VT(POWER, 0, POWER) / 1.5
								O3.Size = O3.Size + VT(POWER, 0, POWER) / 2
							end
							local DIST = (ORB.Position - AIMPOS).Magnitude
							for i = 1, 75 do
								Swait(3)
								CreateRing(VT(0, 0, 0), false, 0, 45, CF(ORB.Position) * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180))), C3(1, 1, 1), VT(POWER, POWER, 0) / 5)
								killnearest(ORB.Position, ORB.Size.X, 200)
								local ZAPTABLE = Zap({
									SIZE = POWER * 2,
									StartPosition = ORB.Position,
									TargetPosition = AIMPOS + VT(MRANDOM(-POWER * 15, POWER * 15), 0, MRANDOM(-POWER * 15, POWER * 15)) * 2,
									Character = Character,
									Color = "Gold",
									Individual = true,
									MaxRange = POWER * 400,
									SegmentLength = DIST / 25,
									Offset = 3 + DIST / 350
								})
								Debris:AddItem(ZAPTABLE.LightningModel, 0.1)
								MagicSphere(ORB.Size * 1.1, 25, CF(ZAPTABLE.RayPos), BRICKC("Gold").Color, ORB.Size / 15)
								killnearest(ZAPTABLE.RayPos, POWER * 45, 60)
								CreateWave(VT(ORB.Size.X, 1, ORB.Size.Z) * 5, 35, CF(ZAPTABLE.RayPos), true, 5, "Gold", -VT(ORB.Size.X / 24, 0, ORB.Size.Z / 24))
							end
							local SIZE = ORB.Size
							for i = 1, 25 do
								Swait()
								ORB.Size = ORB.Size - SIZE / 25
								O1.Size = O1.Size - VT(POWER, 0, POWER)
								O2.Size = O2.Size - VT(POWER, 0, POWER) / 1.5
								O3.Size = O3.Size - VT(POWER, 0, POWER) / 2
							end
							ORB:remove()
							O1:remove()
							O2:remove()
							O3:remove()
						elseif POWER > 3 then
							local O1 = MagicRing()
							local O2 = MagicRing()
							local O3 = MagicRing()
							O1.CFrame = CF(ORB.Position, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X, 0)
							O2.CFrame = CF(ORB.Position, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X + ORB.Size.X / 4, 0)
							O3.CFrame = CF(ORB.Position, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X + ORB.Size.X / 8, 0)
							for i = 1, 25 do
								Swait()
								O1.CFrame = CF(ORB.Position, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X, 0)
								O2.CFrame = CF(ORB.Position, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X + ORB.Size.X / 4, 0)
								O3.CFrame = CF(ORB.Position, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X + ORB.Size.X / 8, 0)
								O1.Size = O1.Size + VT(POWER, 0, POWER)
								O2.Size = O2.Size + VT(POWER, 0, POWER) / 1.5
								O3.Size = O3.Size + VT(POWER, 0, POWER) / 2
							end
							for i = 1, 75 do
								for i = 1, 5 do
									Swait()
									O1.CFrame = CF(ORB.Position, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X, 0)
									O2.CFrame = CF(ORB.Position, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X + ORB.Size.X / 4, 0)
									O3.CFrame = CF(ORB.Position, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X + ORB.Size.X / 8, 0)
								end
								killnearest(ORB.Position, ORB.Size.X, 200)
								CreateRing(VT(0, 0, 0), false, 0, 45, CF(ORB.Position) * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180))), C3(1, 1, 1), VT(POWER, POWER, 0) / 5)
								local DIST = (ORB.Position - Mouse.Hit.p).Magnitude
								local ZAPTABLE = Zap({
									SIZE = POWER,
									StartPosition = ORB.Position,
									TargetPosition = Mouse.Hit.p,
									Character = Character,
									Color = "Gold",
									Individual = true,
									MaxRange = POWER * 400,
									SegmentLength = DIST / 25,
									Offset = 3 + DIST / 350
								})
								Debris:AddItem(ZAPTABLE.LightningModel, 0.1)
								MagicSphere(ORB.Size * 1.1, 25, CF(ZAPTABLE.RayPos), BRICKC("Gold").Color, ORB.Size / 15)
								killnearest(ZAPTABLE.RayPos, POWER * 45, 60)
								CreateWave(VT(ORB.Size.X, 1, ORB.Size.Z) * 5, 35, CF(ZAPTABLE.RayPos), true, 5, "Gold", -VT(ORB.Size.X / 24, 0, ORB.Size.Z / 24))
							end
							local SIZE = ORB.Size
							for i = 1, 25 do
								Swait()
								ORB.Size = ORB.Size - SIZE / 25
								O1.Size = O1.Size - VT(POWER, 0, POWER)
								O2.Size = O2.Size - VT(POWER, 0, POWER) / 1.5
								O3.Size = O3.Size - VT(POWER, 0, POWER) / 2
							end
							ORB:remove()
							O1:remove()
							O2:remove()
							O3:remove()
						end
						coroutine.resume(coroutine.create(function()
							for i = 1, 65 do
								Swait()
								CENTER.Size = CENTER.Size - VT(POWER, 0, POWER)
								CENTER.CFrame = CENTER.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
							end
							CENTER:remove()
						end))
					end))
				end
			elseif POWER > 6 then
				do
					local FINISHED = false
					local YIN = CreatePart(3, Effects, "Neon", 0, 0, "Pearl", "YIN", VT(25, 25, 25))
					local YAN = CreatePart(3, Effects, "Neon", 0, 0, "Gold", "YAN", VT(65, 25, 65))
					coroutine.resume(coroutine.create(function()
						local LOOP = 0
						repeat
							YIN.CFrame = CF(HITPOS + VT(0, 500, 0)) * ANGLES(RAD(0), RAD(LOOP), RAD(0)) * CF(0, 0, 200)
							YAN.CFrame = CF(HITPOS + VT(0, 500, 0)) * ANGLES(RAD(0), RAD(LOOP), RAD(0)) * CF(0, 0, -200)
							LOOP = LOOP + 5
							MagicSphere(VT(500, 5, 500), 65, CF(YIN.Position), BRICKC("Gold").Color, VT(-1, -0.001, -1) * 2)
							MagicSphere(VT(500, 5, 500), 65, CF(YAN.Position), C3(1, 1, 1), VT(-1, -0.001, -1) * 2)
							Swait()
						until FINISHED == true
						YIN:remove()
						YAN:remove()
					end))
					CreateSound("438666077", Effects, 10, 1)
					for i = 0, 1, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(65), RAD(0), RAD(90 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(65), RAD(0), RAD(-90 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					local ORB = CreatePart(3, Effects, "Neon", 0, 0, "Gold", "ORB", VT(6, 6, 6))
					MakeForm(ORB, "Ball")
					ORB.CFrame = CF(HITPOS + VT(0, 150, 0))
					for i = 0, 8, 0.1 / Animation_Speed do
						Swait()
						if MRANDOM(1, 8) == 1 then
							local RANGE1 = (ORB.Position - YIN.Position).Magnitude
							local RANGE2 = (ORB.Position - YAN.Position).Magnitude
							local ZAPTABLE1 = Zap({
								SIZE = POWER / 3,
								StartPosition = YIN.Position,
								TargetPosition = ORB.Position,
								Character = workspace,
								Color = "Pearl",
								Individual = true,
								MaxRange = RANGE1,
								SegmentLength = 25,
								Offset = 6
							})
							local ZAPTABLE2 = Zap({
								SIZE = POWER / 3,
								StartPosition = YAN.Position,
								TargetPosition = ORB.Position,
								Character = workspace,
								Color = "Gold",
								Individual = true,
								MaxRange = RANGE1,
								SegmentLength = 25,
								Offset = 6
							})
							Debris:AddItem(ZAPTABLE1.LightningModel, 0.1)
							Debris:AddItem(ZAPTABLE2.LightningModel, 0.1)
						end
						ORB.Size = ORB.Size + VT(POWER, POWER, POWER) / 15
						RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(0)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(150), RAD(0), RAD(90 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(150), RAD(0), RAD(-90 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					FINISHED = true
					coroutine.resume(coroutine.create(function()
						for i = 1, 6 do
							for e = 1, 10 do
								Swait()
								Slice("Thin", ORB.Size.X / 15, 15, ORB.CFrame * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180))), "Pearl", VT(-0.01, 0, -0.01))
								ORB.Size = ORB.Size * 0.97
								killnearest(ORB.Position, ORB.Size.X * 3, 200)
								CreateWave(VT(ORB.Size.X, 35, ORB.Size.X), 25, CF(HITPOS) * ANGLES(RAD(0), RAD(i * 5 + e * 5), RAD(0)), false, 0, C3(1, 1, 1), VT(POWER, 0, POWER))
							end
							local POS = ORB.Position
							for i = 1, 5 do
								CreateRing(VT(0, 0, 0), false, 0, 8 * i, CF(POS) * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180))), C3(1, 1, 1), VT(POWER, POWER, 0) / 5)
							end
							CreateRing(VT(0, 0, 0), false, 0, 45, CF(POS) * ANGLES(RAD(90), RAD(0), RAD(0)), C3(1, 1, 1), VT(POWER, POWER, 0))
							for e = 1, 10 do
								Swait()
								if MRANDOM(1, 5) == 1 then
									local POS = CF(ORB.Position) * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180))) * CF(0, 0, -POWER * 25).p
									local ZAPTABLE = Zap({
										SIZE = POWER,
										StartPosition = ORB.Position,
										TargetPosition = POS,
										Character = workspace,
										Color = "Gold",
										Individual = true,
										MaxRange = POWER * 75,
										SegmentLength = POWER * 5,
										Offset = 3
									})
									Debris:AddItem(ZAPTABLE.LightningModel, 0.1)
								end
								ORB.Size = ORB.Size * 1.05
								killnearest(ORB.Position, ORB.Size.X * 3, 200)
								CreateWave(VT(ORB.Size.X, 35, ORB.Size.X), 25, CF(HITPOS) * ANGLES(RAD(0), RAD(i * 5 + e * 5), RAD(0)), false, 0, C3(1, 1, 1), VT(POWER, 0, POWER))
							end
						end
						local POS = ORB.Position
						for e = 1, 10 do
							Swait()
							ORB.Transparency = ORB.Transparency + 0.1
						end
						ORB:remove()
						killnearest(POS, POWER * 35, 200)
						for i = 1, 5 do
							CreateRing(VT(0, 0, 0), false, 0, 8 * i, CF(POS) * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180))), C3(1, 1, 1), VT(POWER, POWER, 0) / 5)
						end
						CreateRing(VT(0, 0, 0), false, 0, 45, CF(POS) * ANGLES(RAD(90), RAD(0), RAD(0)), C3(1, 1, 1), VT(POWER, POWER, 0))
					end))
				end
			end
			ATTACK = false
			Rooted = false
		end
	end
end
function Hop()
	ATTACK = true
	Rooted = false
	local O1 = MagicRing()
	local O2 = MagicRing()
	local POS = VT(RootPart.Position.X, Mouse.Hit.p.Y + 6, RootPart.Position.Z)
	O1.CFrame = RootPart.CFrame * CF(0, 0, -3) * ANGLES(RAD(90), RAD(0), RAD(0))
	O2.CFrame = CF(Mouse.Hit.p + VT(0, 6, 0), POS) * ANGLES(RAD(90), RAD(0), RAD(0))
	local ROOT = CreatePart(3, Effects, "Neon", 0, 1, "Really red", "Warphole", VT(0, 0, 0))
	ROOT.CFrame = CF(O2.Position, RootPart.Position)
	CreateSound("814168787", O1, 10, 0.7)
	CreateSound("814168787", O2, 10, 0.7)
	for i = 1, 75 do
		Swait()
		O1.Size = O1.Size + VT(0.15, 0, 0.15)
		O1.CFrame = RootPart.CFrame * CF(0, 0, -3) * ANGLES(RAD(90), RAD(i), RAD(0))
		O2.Size = O2.Size + VT(0.15, 0, 0.15)
		O2.CFrame = O2.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(5 + 6.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.35 + 0.05 * COS(SINE / 12), -0.5) * ANGLES(RAD(90), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	Rooted = true
	UNANCHOR = false
	RootPart.Anchored = true
	VALUE1 = true
	for i = 1, 15 do
		Transparency(i / 15)
		Swait()
		RootPart.CFrame = RootPart.CFrame * CF(0, 0, -0.13)
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(16 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-15 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-15), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-15), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-5 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	RootPart.CFrame = ROOT.CFrame
	ROOT:remove()
	for i = 1, 15 do
		Transparency(1 - i / 15)
		Swait()
		RootPart.CFrame = RootPart.CFrame * CF(0, 0, -0.5)
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(16 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-15 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-15), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-15), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-5 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	VALUE1 = false
	coroutine.resume(coroutine.create(function()
		for i = 1, 75 do
			Swait()
			O1.Size = O1.Size - VT(0.15, 0, 0.15)
			O1.CFrame = O1.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
			O2.Size = O2.Size - VT(0.15, 0, 0.15)
			O2.CFrame = O2.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
		end
		O1:remove()
		O2:remove()
	end))
	UNANCHOR = true
	RootPart.Anchored = false
	ATTACK = false
	Rooted = false
end
function Roar()
	ATTACK = true
	Rooted = true
	local ROAR = CreateSound("199978176", Head, 10, 1)
	Swait()
	repeat
		Swait()
		ROAR.Parent = Head
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(-15 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-45), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(15 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-45), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-15 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-15 - 7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	until ROAR.Playing == false
	ATTACK = false
	Rooted = false
end
function Dimisit()
	ATTACK = true
	Rooted = false
	local LIGHT = IT("ColorCorrectionEffect")
	for LOOP = 1, 500 do
		Swait()
		local MATHMAX = 30 - math.ceil(LOOP / 10)
		if MATHMAX <= 1 then
			MATHMAX = 1
		end
		if MRANDOM(1, MATHMAX) == 1 then
			WACKYEFFECT({
				TIME = MRANDOM(45, 75),
				EffectType = "Sphere",
				Size = VT(0.2, 0.2, 0.2),
				Size2 = VT(3, 3, 3),
				Transparency = 0,
				Transparency2 = 1,
				CFrame = Head.CFrame * CF(0, 0, -0.5),
				MoveToPos = Head.CFrame * CF(MRANDOM(-15, 15) / 2, MRANDOM(-15, 15) / 2, -25).p,
				RotationX = 0,
				RotationY = 0,
				RotationZ = 0,
				Material = "Neon",
				Color = SKILLTEXTCOLOR,
				SoundID = nil,
				SoundPitch = nil,
				SoundVolume = nil
			})
		end
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(-15 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-45), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(15 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-45), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-15 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-15 - 7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	LIGHT.Parent = game.Lighting
	for LOOP = 1, 25 do
		Swait()
		LIGHT.Brightness = LIGHT.Brightness + 0.04
		LIGHT.Parent = game.Lighting
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(-15 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-45), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(15 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-45), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-15 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-15 - 7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	for i = 1, 10 do
		Swait()
		Volume = Volume - 0.15
	end
	CREATION = true
	Volume = 3
	wait(2)
	for LOOP = 1, 25 do
		Swait()
		LIGHT.Brightness = LIGHT.Brightness - 0.04
		LIGHT.Parent = game.Lighting
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(-15 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-45), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(15 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-45), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-15 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-15 - 7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	LIGHT:remove()
	coroutine.resume(coroutine.create(function()
		repeat
			Swait()
		until CREATION == false
	end))
	ATTACK = false
	Rooted = false
end
function AttackTemplate()
	ATTACK = true
	Rooted = false
	for i = 0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-5 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end
function MouseDown(Mouse)
	if ATTACK == false then
	end
end
function MouseUp(Mouse)
	HOLD = false
end
function KeyDown(Key)
	KEYHOLD = true
	if Key == "z" and ATTACK == false then
		if CREATION == false then
			Dolor_Pluvia()
		elseif CREATION == true then
		end
	end
	if Key == "b" and ATTACK == false then
		if CREATION == false then
			Ignem_Aeternum()()
		elseif CREATION == true then
		end
	end
	if Key == "c" and ATTACK == false then
		if CREATION == false then
			Imperium_Delere()()
		elseif CREATION == true then
		end
	end
	if Key == "q" and ATTACK == false then
		if CREATION == false then
			Hop()
		elseif CREATION == true then
		end
	end
	if Key == "x" and ATTACK == false then
		if CREATION == false then
			Ultima_Consummatio()()
		elseif CREATION == true then
		end
	end
	if Key == "t" and ATTACK == false then
		Roar()
	end
	if Key == "1" and ATTACK == false then
		LEVEL = 1
	end
	if Key == "2" and ATTACK == false then
		LEVEL = 2
	end
	if Key == "3" and ATTACK == false then
		LEVEL = 3
	end
	if Key == "4" and ATTACK == false then
		LEVEL = 4
	end
	if Key == "5" and ATTACK == false then
		LEVEL = 5
	end
	if Key == "6" and ATTACK == false then
		LEVEL = 6
	end
	if Key == "7" and ATTACK == false then
		LEVEL = 7
	end
	if Key == "8" and ATTACK == false then
		LEVEL = 8
	end
	if Key == "9" and ATTACK == false then
		LEVEL = 9
	end
	if Key == "]" and ATTACK == false then
		if CREATION == false then
			Dimisit()
		elseif CREATION == true then
		end
	end
end
function KeyUp(Key)
	KEYHOLD = false
end
Mouse.Button1Down:connect(function(NEWKEY)
	MouseDown(NEWKEY)
end)
Mouse.Button1Up:connect(function(NEWKEY)
	MouseUp(NEWKEY)
end)
Mouse.KeyDown:connect(function(NEWKEY)
	KeyDown(NEWKEY)
end)
Mouse.KeyUp:connect(function(NEWKEY)
	KeyUp(NEWKEY)
end)
function unanchor()
	if UNANCHOR == true then
		g = Character:GetChildren()
		for i = 1, #g do
			if g[i].ClassName == "Part" then
				g[i].Anchored = false
			end
		end
	end
end
Humanoid.Changed:connect(function(Jump)
	if Jump == "Jump" and Disable_Jump == true then
		Humanoid.Jump = false
	end
end)
Humanoid.HipHeight = 2.5
local FF = IT("ForceField", Character)
FF.Visible = false
Speed = 65
local LIGHT = IT("PointLight", Torso)
LIGHT.Range = 5
LIGHT.Brightness = 100
LIGHT.Color = C3(1, 1, 1)
while true do
	refit()
	Swait()
	script.Parent = WEAPONGUI
	Character.Parent = workspace
	ANIMATE.Parent = nil
	local IDLEANIMATION = Humanoid:LoadAnimation(ROBLOXIDLEANIMATION)
	IDLEANIMATION:Play()
	SINE = SINE + CHANGE
	local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
	local TORSOVERTICALVELOCITY = RootPart.Velocity.y
	local LV = Torso.CFrame:pointToObjectSpace(Torso.Velocity - Torso.Position)
	local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 7 * Player_Size, Character)
	if ATTACK == false then
		if TORSOVELOCITY < 1 then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(5 + 6.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-45 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif TORSOVELOCITY > 1 then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(25 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-45 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	end
	unanchor()
	if Rooted == false then
		Disable_Jump = false
		Speed = 65
	elseif Rooted == true then
		Disable_Jump = true
		Speed = 0
	end
	for _, c in pairs(Character:GetChildren()) do
		if c.ClassName == "Part" then
			c.Material = "Neon"
			for _, q in pairs(c:GetChildren()) do
				if q.ClassName == "ParticleEmitter" and q.Name ~= "OVERLORDAURA" then
					q:remove()
				elseif q.ClassName == "Fire" then
					q:remove()
				end
			end
			if c.Transparency == 0 and c:FindFirstChild("OVERLORDAURA") == nil then
				particles(c)
			end
			if c == Torso then
				c.Color = C3(1, 1, 1)
			elseif c == RightArm then
				c.Color = C3(0.9372549019607843, 0.7215686274509804, 0.2196078431372549)
			elseif c == LeftArm then
				c.Color = C3(0.9372549019607843, 0.7215686274509804, 0.2196078431372549)
			elseif c == RightLeg then
				c.Color = C3(0.7372549019607844, 0.6078431372549019, 0.36470588235294116)
			elseif c == LeftLeg then
				c.Color = C3(0.7372549019607844, 0.6078431372549019, 0.36470588235294116)
			elseif c == Head then
				if c:FindFirstChild("Dominus") == nil then
					local M = CreateMesh("SpecialMesh", c, "FileMesh", "21057410", "1393532942", VT(1, 1, 1) * 1.1, VT(0, 0, 0))
					M.Name = "Dominus"
				end
				if c:FindFirstChild("face") then
					c.face:remove()
				end
			end
		elseif c.ClassName == "Shirt" or c.ClassName == "Pants" or c.ClassName == "CharacterMesh" or c.ClassName == "Accessory" or c.Name == "Body Colors" then
			c:remove()
		end
	end
	sick.Playing = true
	sick.Pitch = 1
	sick.Volume = Volume
	FF.Parent = Character
	sick.Parent = Character
	Humanoid.PlatformStand = false
	Humanoid.Name = "PHAEDRA"
	Humanoid.DisplayDistanceType = "None"
	for _, c in pairs(workspace:GetChildren()) do
		if c.ClassName == "Model" and c ~= Character then
			for _, q in pairs(c:GetChildren()) do
				if q.ClassName == "Sound" then
					q.Pitch = 0
				end
			end
		end
	end
	refit()
	if CREATION == false then
		if sick.SoundId ~= SONG1 then
			sick.SoundId = SONG1
			sick:Play()
		end
	elseif CREATION == true and sick.SoundId ~= SONG2 then
		sick.SoundId = SONG2
		sick:Play()
	end
end